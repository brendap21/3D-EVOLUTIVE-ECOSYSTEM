package ui;

import java.awt.Component;
import java.awt.Cursor;
import java.awt.Point;
import java.awt.Robot;
import java.awt.Toolkit;
import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;
import java.awt.event.MouseEvent;
import java.awt.event.MouseMotionListener;
import java.awt.image.BufferedImage;
import math.Camera;
import math.Vector3;

// Controles mejorados: mouse-lock (centro + oculto) usando Robot y movimiento WASD
// relativo a la dirección de la cámara (comportamiento tipo Minecraft).
public class Controles extends KeyAdapter implements MouseMotionListener {

    private Camera cam;
    private boolean[] teclas = new boolean[256];
    private double velocidad = 5.0;
    private double sensibilidad = 0.0035; // ajustar sensibilidad del mouse
    private int lastX = -1, lastY = -1;

    // Mouse lock
    private Robot robot;
    private Component comp; // componente donde se captura el mouse (RenderPanel)
    private boolean mouseLocked = false;
    private int centerXScreen = 0, centerYScreen = 0;
    private Cursor blankCursor;
    private boolean flyMode = true; // when true, W/S move along full forward vector (including Y)
    private boolean crosshairVisible = true;
    // Pause state
    private boolean paused = false;
    // For free-look absolute mapping
    private double baseYaw = 0.0;
    private double basePitch = 0.0;
    private boolean freeLookBaseSet = false;

    public Controles(Camera cam, Component comp) {
        this.cam = cam;
        this.comp = comp;
        try {
            robot = new Robot();
        } catch (Exception ex) {
            robot = null;
        }

        // Cursor invisible
        BufferedImage cursorImg = new BufferedImage(16, 16, BufferedImage.TYPE_INT_ARGB);
        blankCursor = Toolkit.getDefaultToolkit().createCustomCursor(cursorImg, new Point(0, 0), "blank cursor");
    }

    // Lock or unlock the mouse. When locked, the cursor is hidden and recentred to the panel center.
    public void lockMouse(boolean lock) {
        if (lock == mouseLocked) return;
        mouseLocked = lock;
        if (mouseLocked) {
            // compute center in screen coordinates
            Point p = comp.getLocationOnScreen();
            centerXScreen = p.x + comp.getWidth()/2;
            centerYScreen = p.y + comp.getHeight()/2;
            if (robot != null) robot.mouseMove(centerXScreen, centerYScreen);
            comp.setCursor(blankCursor);
            comp.requestFocus();
            // initialize last positions to center
            lastX = comp.getWidth()/2;
            lastY = comp.getHeight()/2;
        } else {
            comp.setCursor(Cursor.getDefaultCursor());
            // reset last positions so free-look restarts smoothly
            lastX = -1;
            lastY = -1;
            // reset free-look baseline so we'll compute it next frame
            freeLookBaseSet = false;
        }
    }

    @Override
    public void keyPressed(KeyEvent e) {
        if (e.getKeyCode() < 256)
            teclas[e.getKeyCode()] = true;
        // NOTE: ESC is reserved for pause/menu; do NOT unlock the mouse with ESC.
        // Fly mode is always ON in this build (no toggle)
        // Toggle crosshair with 'C'
        if (e.getKeyCode() == KeyEvent.VK_C) {
            crosshairVisible = !crosshairVisible;
        }
        // Toggle pause with ESC: when paused, show the menu and stop the game updates.
        if (e.getKeyCode() == KeyEvent.VK_ESCAPE) {
            setPaused(!paused);
        }
    }

    @Override
    public void keyReleased(KeyEvent e) {
        if (e.getKeyCode() < 256)
            teclas[e.getKeyCode()] = false;
    }

    @Override
    public void mouseMoved(MouseEvent e) {
        if (mouseLocked) {
            if (robot == null) return;
            // Use screen coordinates so we can recenter with Robot
            int mouseX = e.getXOnScreen();
            int mouseY = e.getYOnScreen();

            int dx = mouseX - centerXScreen;
            int dy = mouseY - centerYScreen;

            // deadzone to ignore tiny movements and the synthetic event generated by Robot
            int deadzone = 1;
            if (Math.abs(dx) <= deadzone && Math.abs(dy) <= deadzone) {
                // ensure last positions match center to avoid accumulation
                lastX = comp.getWidth()/2;
                lastY = comp.getHeight()/2;
                return;
            }

            // apply rotation and recentre cursor
            cam.rotate(dx * sensibilidad, -dy * sensibilidad);
            if (robot != null) {
                robot.mouseMove(centerXScreen, centerYScreen);
                // update last known local positions to the center
                lastX = comp.getWidth()/2;
                lastY = comp.getHeight()/2;
            }
        } else {
            // In free-look we update orientation each frame in actualizar();
            // keep lastX/lastY for potential use but don't apply incremental rotates here.
            lastX = e.getX();
            lastY = e.getY();
        }
    }

    @Override
    public void mouseDragged(MouseEvent e) {
        mouseMoved(e);
    }

    public void actualizar() {
        // Update camera orientation from mouse position when not locked (absolute mapping)
        if (!mouseLocked) {
            // compute baseline yaw/pitch once when entering free-look
            if (!freeLookBaseSet) {
                baseYaw = cam.getYaw();
                basePitch = cam.getPitch();
                freeLookBaseSet = true;
            }
            java.awt.Point mp = comp.getMousePosition();
            if (mp != null) {
                int centerXLocal = comp.getWidth() / 2;
                int centerYLocal = comp.getHeight() / 2;
                int dx = mp.x - centerXLocal;
                int dy = mp.y - centerYLocal;
                double newYaw = baseYaw + dx * sensibilidad;
                double newPitch = basePitch - dy * sensibilidad;
                cam.setOrientation(newYaw, newPitch);
            }
        }

        Vector3 dir = new Vector3(0, 0, 0);

        // Movimiento: si estamos en flyMode, mover según el forward completo (incluye Y),
        // permitiendo volar hacia donde apunte la cámara. Si no, movemos plano XZ según yaw.
        if (flyMode) {
            Vector3 f = cam.getForward().normalize();
            // Use forward for W/S (includes Y). For strafing, keep horizontal right to avoid unintended vertical strafing.
            double yaw = cam.getYaw();
            double yawRight = yaw + Math.PI/2.0;
            Vector3 rightXZ = new Vector3(Math.sin(yawRight), 0, Math.cos(yawRight)).normalize();

            if(teclas[KeyEvent.VK_W]) dir = dir.add(f.scale(velocidad));
            if(teclas[KeyEvent.VK_S]) dir = dir.subtract(f.scale(velocidad));
            if(teclas[KeyEvent.VK_D]) dir = dir.add(rightXZ.scale(velocidad));
            if(teclas[KeyEvent.VK_A]) dir = dir.subtract(rightXZ.scale(velocidad));
        } else {
            double yaw = cam.getYaw();
            Vector3 forwardXZ = new Vector3(Math.sin(yaw), 0, Math.cos(yaw)).normalize();
            double yawRight = yaw + Math.PI/2.0;
            Vector3 rightXZ = new Vector3(Math.sin(yawRight), 0, Math.cos(yawRight)).normalize();

            if(teclas[KeyEvent.VK_W]) dir = dir.add(forwardXZ.scale(velocidad));
            if(teclas[KeyEvent.VK_S]) dir = dir.subtract(forwardXZ.scale(velocidad));
            if(teclas[KeyEvent.VK_D]) dir = dir.add(rightXZ.scale(velocidad));
            if(teclas[KeyEvent.VK_A]) dir = dir.subtract(rightXZ.scale(velocidad));
        }

        if(teclas[KeyEvent.VK_DOWN] || teclas[KeyEvent.VK_CONTROL]) dir = dir.add(new Vector3(0, velocidad, 0));
        if(teclas[KeyEvent.VK_UP] || teclas[KeyEvent.VK_SPACE]) dir = dir.subtract(new Vector3(0, velocidad, 0));

        cam.setPosicion(cam.getPosicion().add(dir));
    }

    public boolean isPaused(){
        return paused;
    }

    // Set pause state. When paused we unlock the mouse so the user can click the
    // pixel-drawn menu buttons; when unpausing we lock the mouse again for FPS-style control.
    public void setPaused(boolean p){
        if (this.paused == p) return;
        this.paused = p;
        if (paused) {
            // show cursor so user can interact with menu
            lockMouse(false);
        } else {
            // resume: re-lock mouse for gameplay
            lockMouse(true);
            // reset free-look baseline when returning to gameplay
            freeLookBaseSet = false;
        }
    }

    public boolean isCrosshairVisible() {
        return crosshairVisible;
    }
}
